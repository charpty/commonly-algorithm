/**
 * 挖矿问题，有w个工作，有n座金矿，每座金矿的价值为G[n], 每座金矿需要P[n]个工人挖，求最大收益
 *
 * 这是一个二维的动态规划问题
 *
 * 解决思路：先找到最有子结构，我觉得就是找到循环递归处理时的表达式，大可以用怎么使用递归来解决这个问题的思路去想
 * 经过思考我们可以得到这样一个表达式
 * 1、F(n,w) = 0 ; n<=1 && w<P[n-1] ; 只有一座矿可挖但工人又不够挖该矿
 * 2、F(n,w) = G[n-1] ; n=1 && w>=P[n-1] ; 只剩一个矿了，工人也够的情况
 * 3、F(n,w) = F(n-1,w) n>1 && w<P[n-1] ; 工人不够挖第n个矿的情况
 * 4、F(n,w) = max(F(n-1,w),F(n-1,w-P[n-1])+G[n-1]) ; n>1, w>=P[n-1]
 *
 * 1、2称为问题的边界，3则是一个逻辑理解，不够挖这个矿，当然是放弃这个矿了
 * 4则是最优子结构的直接表达，当条件充分时，要比较挖这个矿和不挖这个矿的收益谁更大
 *
 * 问题用递归是肯定能解决的，有了上面的表达式都可以写出来。我理解动态规划的精髓就在于，你要自底向上看问题！
 * 将思路倒过来，递归的时候你是从后往前推导求解，比如有10个工人，5座金矿，是这样求解的
 *
 * F(5,10) = max(F(4,10), F(4,w-P[4])+G[4]) =
 * = max(max(F(3,10),F(3,w-P[3])+G[3]),max(F(3,w-P[4])+G[4],F(3,w-P[4]-P[3])+G[3]+G[4]))
 * = ....
 * = max(F(1,w) ...
 * 总是先求离边界远的值，最后再求边界值，如果先求边界值，则方便效率高的多
 *
 * 从F(1,1)->F(1,2)...->F(1,10)这一排开始求解，第一排因为只有一个矿，够人挖最大收益就是G[0],不够就是0
 * F(2,1),如果1<P[1]，那么结果就为F(1,1)，这个值已经算出来了
 * 如果1>=P[1],那么结果就是max(F(1,1), F(1,1-P[1])+G[1]),这个结果也是完全可计算的
 * 每一步值的结果仅仅依赖于上一步的计算结果，而和未来要计算的结果无关，逐个推算，最终结果也就出来了
 */
class DP1 {

	public static void main(String[] args) {

	}
}